# 代码分层设计实践

本篇的主要内容来自于

[goframe的官方文档]: https://goframe.org/pages/viewpage.action?pageId=3672442



## 代码分层

在前后端揉在一起的项目中，MVC是最流行的架构模式。

### MVC

- View（视图）
  - 与用户交互的界面。在Web项目中，一般是由`HTML`元素组成的页面。用户通过View可以对后端服务发出指令，发出指令的方式一般是请求后端提供的api。并且把指令返回的结果渲染到`HTML`页面中。
- Controller（控制器）
  - 接收来自View层的指令，并通过选择调用一个或者多个Model来完成指令，它本身不会有任何的业务逻辑。调用完成后，会选取一个视图作为对用户的指令结果展示。
- Model（模型）
  - 真正实现业务逻辑的地方。

MVC的好处是，Model层与View层被Controller层隔离了。由Controller充当中间层来为View挑选Model，一个Model也能为多个不同的View使用。

当页面需要改进样式时，只需要针对View修改，而不影响Model。同理业务逻辑发生改动时，也不影响View。

但是现在很多项目都采用了前后端分离的方式，后端人员只对前端提供接口，并不关心原来的View层。后端项目就只剩下了MC两层。而M层是颗粒度较粗的：

- M层应该是不包含数据库操作的，但是这个架构里面也没有定义数据库操作该放在哪，结果都揉在了Model里。
- 写着写着发现Controller里面出现了业务逻辑，甚至出现了数据库操作。

所以需要一种针对后端代码分层职责划分颗粒度更细的架构设计

### 3层架构

三层架构设计（3-Tier Architecture）分为表示层、业务逻辑层、数据访问层

- 表示层（User Interface）
  - 与用户直接接触，在web项目中就理解成`API`接口
  - 表示层的主要功能是web服务和请求方的数据的交互
  - 总的来说，表示层就是实现用户界面`API`功能，将用户的需求传达给业务逻辑层，并将处理结果反馈给用户。
- 业务逻辑层（Business Logic Layer）
  - `Business Logic Layer`的功能是对具体问题进行逻辑判断与执行操作
  - 接收到表现层`UI`的用户指令后，就会开始执行业务逻辑。业务逻辑很多情况下需要使用数据库。
- 数据访问层（Data Access Layer）
  - `Data Access Layer`是数据库的主要操控系统，实现数据的增删改查等操作，并将操作结果反馈到业务逻辑层`BLL`。在实际运行的过程中，数据访问层没有逻辑判断能力，为了实现代码编写的严谨性，提高代码阅读程度，一般软件开发人员会在该层中实现通用数据能力进行封装（例如通过`ORM`组件）来保证数据访问层`DAL`数据处理功能。 



`GoFrame`框架推荐的代码分层设计模式为三层架构设计（`3-Tier Architecture`），但在具体的实现中，对这种结构设计模式进行了一定的改进。三层架构设计能够很好地体现出软件设计"高内聚，低耦合"的设计思想。



图2. 三层架构设计模式

传统的三层架构设计如上图，将项目代码划分了三层，每一层有其独自的职责边界。但在大多数的场景中，我们常看到的是以下的分层结构，将数据结构模型再进一步地抽离了出来统一维护。

图3. 常见三层架构设计模型

## 

## 模型定义层 - `Model`

模型定义也常用`Entity`实体对象来表示，主要用于数据库表的映射对象，在信息系统软件实际开发的过程中，要建立对象实例，将关系数据库表采用对象实体化的方式表现出来，辅助软件开发中对各个系统功能的控制与操作执行。建立实体类库，进而实现各个结构层的参数传输，提高代码的阅读性。从本质上看，实体类库主要服务于表示层、业务逻辑层以及数据访问层，在三层之间进行数据参数传输，强化数据表示的简约性。

需要注意区分的是，这里的`Model`和`MVC`设计模式中的`Model`虽然都是一个名字但是差别巨大，职责完全不同。

## 三层架构设计与`MVC`

由于`MVC`也是三层结构，因此有的同学也会将`MVC`笼统地归纳于三层架构设计中，从字面意义上来讲似乎也没什么问题。不过两者还是存在一定的区别。

图4. 三层架构设计与MVC

可以看到，在三层架构设计中，`UI`表示层即相当于`MVC`的`View`和`Controller`层，原本在`MVC`中这两层的逻辑应当是比较"轻量"的，因此被合并为一层进行统一管理也可以理解。比较重要的一点是，原本`MVC`中的`Model`被拆分为了`BLL`和`DAL`，即将业务逻辑与数据访问进行分离，将原本臃肿的`Model`进行了进一步的解耦，有利于项目的更好维护。